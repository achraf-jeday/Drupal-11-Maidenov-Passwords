<?php

/**
 * @file
 * Contains user_confidential_data.module.
 *
 * Filtering on encrypted fields is handled by the custom Query class.
 * @see \Drupal\user_confidential_data\Entity\Query\Sql\Query
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Database\Query\AlterableInterface;

/**
 * Implements hook_query_TAG_alter() for user_confidential_data_access.
 *
 * Filters user_confidential_data entity queries to show only owned entities
 * for non-admin users. This ensures JSON:API and other entity lists are
 * properly filtered by ownership.
 *
 * WHEN THIS RUNS:
 * - Any EntityQuery on user_confidential_data entities with the access tag
 * - JSON:API collection requests
 * - Entity reference autocomplete
 * - Views (if configured to check entity access)
 *
 * WHAT IT DOES:
 * - Super admin (uid=1): No filtering, sees all entities
 * - Regular users: Filters to show only entities where user_id = current user
 * - Applies to both the main query AND the count query
 */
function user_confidential_data_query_user_confidential_data_access_alter(AlterableInterface $query) {
  $account = \Drupal::currentUser();

  // Super admin (uid = 1) can see everything - no filtering needed.
  if ($account->id() == 1) {
    return;
  }

  // Check if user has any "own" permissions.
  $has_own_permission = $account->hasPermission('view own user confidential data')
    || $account->hasPermission('edit own user confidential data')
    || $account->hasPermission('delete own user confidential data');

  // Get the base table alias.
  $tables = $query->getTables();
  $base_table = '';
  foreach ($tables as $table_info) {
    if (isset($table_info['table']) && $table_info['table'] === 'user_confidential_data') {
      $base_table = $table_info['alias'];
      break;
    }
  }

  if (!$base_table) {
    return;
  }

  // If user has "own" permissions, filter by ownership.
  if ($has_own_permission) {
    // Add WHERE condition: user_id = current user ID.
    // This filters the query to show only entities owned by the current user.
    $query->condition($base_table . '.user_id', $account->id());
  }
  else {
    // User has no permissions to view any entities.
    // Add an impossible condition to return empty result.
    // Use a condition that will never match (entity ID cannot be NULL).
    $query->isNull($base_table . '.id');
  }
}

/**
 * Implements hook_query_TAG_alter() for edit access.
 *
 * Filters user_confidential_data entity queries for edit operations.
 * Ensures users can only edit their own entities.
 *
 * WHEN THIS RUNS:
 * - EntityQuery with user_confidential_data_edit_access tag
 * - Bulk edit operations via EntityQuery
 *
 * WHAT IT DOES:
 * - Super admin (uid=1): No filtering, can edit all entities
 * - Regular users: Filters to show only entities where user_id = current user
 * - Users without edit permission: Returns empty result
 */
function user_confidential_data_query_user_confidential_data_edit_access_alter(AlterableInterface $query) {
  $account = \Drupal::currentUser();

  // Super admin (uid = 1) can edit everything - no filtering needed.
  if ($account->id() == 1) {
    return;
  }

  // Check if user has edit own permission.
  $has_edit_permission = $account->hasPermission('edit own user confidential data');

  // Get the base table alias.
  $tables = $query->getTables();
  $base_table = '';
  foreach ($tables as $table_info) {
    if (isset($table_info['table']) && $table_info['table'] === 'user_confidential_data') {
      $base_table = $table_info['alias'];
      break;
    }
  }

  if (!$base_table) {
    return;
  }

  // If user has edit permission, filter by ownership.
  if ($has_edit_permission) {
    // Add WHERE condition: user_id = current user ID.
    $query->condition($base_table . '.user_id', $account->id());
  }
  else {
    // User cannot edit any entities.
    // Add an impossible condition to return empty result.
    $query->isNull($base_table . '.id');
  }
}

/**
 * Implements hook_query_TAG_alter() for delete access.
 *
 * Filters user_confidential_data entity queries for delete operations.
 * Ensures users can only delete their own entities.
 *
 * WHEN THIS RUNS:
 * - EntityQuery with user_confidential_data_delete_access tag
 * - Bulk delete operations via EntityQuery
 *
 * WHAT IT DOES:
 * - Super admin (uid=1): No filtering, can delete all entities
 * - Regular users: Filters to show only entities where user_id = current user
 * - Users without delete permission: Returns empty result
 */
function user_confidential_data_query_user_confidential_data_delete_access_alter(AlterableInterface $query) {
  $account = \Drupal::currentUser();

  // Super admin (uid = 1) can delete everything - no filtering needed.
  if ($account->id() == 1) {
    return;
  }

  // Check if the user has the delete own permission.
  $has_delete_permission = $account->hasPermission('delete own user confidential data');

  // Get the base table alias.
  $tables = $query->getTables();
  $base_table = '';
  foreach ($tables as $table_info) {
    if (isset($table_info['table']) && $table_info['table'] === 'user_confidential_data') {
      $base_table = $table_info['alias'];
      break;
    }
  }

  if (!$base_table) {
    return;
  }

  // If the user has the delete permission, filter by ownership.
  if ($has_delete_permission) {
    // Add WHERE condition: user_id = current user ID.
    $query->condition($base_table . '.user_id', $account->id());
  }
  else {
    // User cannot delete any entities.
    // Add an impossible condition to return empty result.
    $query->isNull($base_table . '.id');
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for user_login_form.
 */
function user_confidential_data_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Add custom validation handler at the beginning of the validation chain.
  array_unshift($form['#validate'], 'user_confidential_data_user_login_validate');
}

/**
 * Custom validation handler for user login form.
 *
 * Restricts standard login form access to admin user (uid=1) only.
 * All other users must authenticate via OAuth.
 */
function user_confidential_data_user_login_validate(array &$form, FormStateInterface $form_state) {
  $username = $form_state->getValue('name');

  // Load user by username.
  $users = \Drupal::entityTypeManager()
    ->getStorage('user')
    ->loadByProperties(['name' => $username]);

  if (!empty($users)) {
    $user = reset($users);

    // Block login if user is not admin (uid != 1).
    if ($user->id() != 1) {
      $form_state->setErrorByName('name', t('Standard login is disabled. Please use OAuth authentication.'));
    }
  }
}

/**
 * Implements hook_page_attachments().
 *
 * Adds 'user' cache context for JSON:API user_confidential_data endpoints.
 * This ensures Dynamic Page Cache creates separate cache entries per user.
 *
 * WHY THIS IS NEEDED:
 * - The query alter hook filters results by user, but doesn't add cache metadata
 * - Without this, Dynamic Page Cache serves the same cached response to all users
 * - This hook tells Drupal: "cache varies by which user is logged in"
 */
function user_confidential_data_page_attachments(array &$attachments) {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();

  // Check if this is a JSON:API route for user_confidential_data.
  if ($route_name && str_starts_with($route_name, 'jsonapi.user_confidential_data')) {
    // Add user cache context to ensure cache varies per user.
    $attachments['#cache']['contexts'][] = 'user';
  }
}
